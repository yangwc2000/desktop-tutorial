#include <iostream> // 입출력을 제공하는 라이브러리. iostream : input output stream

// 궁금한 점 1 - 라이브러리란? : 자주 사용되는 기능을 미리 만들어 둔 '도구상자'

// 궁금한 점 2 - 라이브러리를 명령어를 통해 명시적으로 불러와야 하는 이유?
//            1. 프로그램 크기와 성능을 최적화 2. 컴파일 시간 단축 3. 가독성 및 유지보수성 향상 4. 충돌 및 중복 방지
 
// 궁금한 점 3 - 그럼 라이브러리라는 것은 어디에 저장되어 있는 것을 불러오는 것일까?
//            : 라이브러리는 컴퓨터에 미리 설치된 파일들에서 불러오는 것.
 
// 라이브러리 파일의 형태 : 1. 헤더파일(.h /.hpp)  2. 바이너리 파일(.lib /.a /.dll /.so)
//                          (전에 C++ 첫 수업 때 .h 형식의 파일을 만들어서 폴더 안의 내용들을 숨겼던 적이 있었는데 그게 헤더파일이었구나.)


using namespace std; // 네임스페이스 선언 (std::cout 대신 cout으로 간단하게 사용할 수 있게 해줌)

// 함수 선언
int calculateSum(int arr[], int size); // calculateSum: 배열의 합을 계산.
double calculateAverage(int sum, int size); // calculateAverage: 합계와 크기를 이용해 평균을 계산.

// calculateSum과 calculateAverage는 고유함수(표준 라이브러리나 시스템에서 제공하는 내장함수)가 아니라 '사용자 정의 함수'임.
// 
// 궁금한 점 1 - 사용자 정의 함수를 만든 이유?
//            : 가독성과 재사용성을 위해서.
//              일회성의 간단한 프로그램을 위해서는 main 함수만 존재해도 되지만, 일정 규모 이상의 프로그램에서는 다른 배열에서도 반복적으로 사용하기 위해 
//              미리 개별적으로 함수를 정의해두면, 나중에 그 함수를 호출해서 쓰기만 하면 됨.

// arr[] : 배열(Array)을 나타내는 표현. 같은 데이터 타입의 값을 연속적으로 저장할 수 있는 자료구조. 데이터를 효율적으로 관리하고 접근. (빈괄호 [] 의 의미 : 배열임을 나타내는 표기)
//         위에서의 함수가 배열을 매개변수로 받았다는 의미로 쓰임.

// size : 배열의 크기를 매개변수로 받음.

// 궁금한 점 2 - 매개변수란? : 함수를 호출할 때 함수에 전달되는 입력값을 담기 위해 사용되는 변수. 쉽게 말해, 함수가 작업을 수행하는 데 필요한 데이터를 전달받는 수단.

// 궁금한 점 3 - 배열이란? : 여러 개의 데이터를 순서대로 저장하는 공간. 배열의 모든 요소는 **메모리 상에서 연속된 공간에 저장된다**는 특징이 있음.

// 궁금한 점 4 - **메모리 상에서 연속된 공간에 저장된다** 이게 무슨 말이지?
//            : 배열의 각 요소가 물리적으로 메모리에서 서로 바로 옆에 위치한다는 것을 의미.
//              인덱스를 이용해 해당 요소의 주소를 계산하고 직접 접근하므로, '**시간 복잡도** O(1)'로 매우 빠르게 동작함.
//              그리고 메모리를 효율적으로 관리할 수 있고 포인터 연산 활용도 가능해짐.

// 궁금한 점 5 - **시간 복잡도** 가 뭐지? 
//            : 알고리즘이 작업을 수행하는 데 걸리는 시간의 증가율을 나타내는 척도
//                 - O(1) : 입력 크기와 상관없이 항상 일정한 시간. 실행 시간은 한두 번의 연산으로 끝나기 때문에 매우 빠름.
//                 - O(n): 입력 크기에 비례하여 실행 시간 증가.
//                 - O(n²): 입력 크기에 따라 실행 시간이 제곱 비율로 증가.

int main() 
{
    const int SIZE = 5; // 배열의 크기를 나타내는 '상수' SIZE를 선언
                        // 궁금한 점 1 - const란? : 그 값이 변하지 않는 불변량으로, 변수의 반대말. (constant)
                        // 궁금한 점 2 - const의 역할? : 변수의 값을 변경하지 못하게 고정해 주고, 코드를 읽고 작성할 때 의미를 명확히 전달해 준다. 그리고 프로그램 실행 중 실수로 값이 변경되는 것을 방지해 준다.
                        //                            즉, const int SIZE = 5; 는 5라는 값이 고정되어, 읽기 전용으로 사용된다는 의미이다.

    int numbers[SIZE];  // 숫자를 저장할 배열

                        // 궁금한 점 - 근데 배열 크기 즉, 괄호[] 안의 숫자는 변하지 않는다고 배웠는데, 굳이 상수 SIZE를 넣은 이유가 뭘까?
                        // 
                        //   1. 숫자를 직접 쓰면 "매직 넘버" 문제가 생길 수 있다. 
                        //      - 코드의 의미를 명확히 하는 것. "5"라는 숫자가 배열 크기를 뜻하는지, 다른 의미인지 코드만 봐서는 명확하지 않다.
                        //   2. 유지보수 용이.
                        //      - 배열 크기를 상수로 선언하면, 크기를 변경할 때 한 곳만 수정하면 됨.
                        //      - 숫자를 여러 곳에 반복해서 쓰면, 크기를 변경할 때 모든 숫자를 찾아 수정해야 하는 비효율성이 생김.
                        //   3. 코드 안정성 증가 (실수 방지)
                        //      - 상수를 사용하면, 실수로 배열 크기를 변경하지 못하게 보호할 수 있음.
                        //      - 만약 일반 변수를 사용하면, 실행 중에 크기를 변경하려는 시도가 생길 수 있음.
                        //        예) int size = 10;
                        //            int numbers[size];  // 일부 컴파일러에서 오류 발생 
                        //            size = 20;          // 배열 크기를 변경하려는 시도
                        //   4. 컴파일러 최적화
                        //      - 컴파일러는 const 상수를 사용한 배열 크기를 컴파일 시간에 최적화할 수 있음.
                        //      - 반면, 일반 변수는 컴파일러가 정적으로 배열 크기를 예측할 수 없으므로 최적화가 제한될 수 있음.


    // 사용자로부터 숫자 입력
    cout << "5개의 숫자를 입력하세요:" << endl; // endl은 줄바꿈 역할.
    
    // 궁금한 점 1 - cout 뒤에 '<<' 이 기호는 정확히 어떤 의미로 사용될까?
    //              '<<' 는 스트림 삽입 연산자(Stream Insertion Operator) 이다. 출력하려는 데이터를 출력 스트림에 "삽입"한다는 의미로 사용됨.
    //              여러 데이터를 출력할 때도 계속 <<를 사용하면 차례로 출력 가능.
    // 
    // 궁금한 점 2 - 왜 부등호 두 개를 사용할까?
    //               : '<<' 는 단순히 부등호가 아니라 C++의 연산자 오버로딩(Operator Overloading)에 의해 정의된 특별한 연산자이다.
    //                - 출력 연산자로 동작하는 이유 : C++ 표준 라이브러리에서 ostream 클래스가 '<<' 를 출력 연산자로 정의해둠.


    for (int i = 0; i < SIZE; i++) // for 반복문: i가 0부터 SIZE-1(=4) 까지 반복. 여기서 i++ 은 증감연산자. 조건에 만족할 때까지 1씩 증가시켜준다.
                                   // 궁금한 점 - i가 0부터 시작하는 이유는? : 인덱스는 0부터 시작하기 때문.
    {
        cout << i + 1 << "번째 숫자: ";
        cin >> numbers[i]; // 사용자가 입력한 숫자를 배열 numbers의 i번째에 저장.
    }

    // 합계 계산
    int sum = calculateSum(numbers, SIZE); // calculateSum 함수 호출로 배열의 모든 요소의 합계를 계산하여 sum 변수에 저장.

    // 평균 계산
    double average = calculateAverage(sum, SIZE); // calculateAverage 함수 호출로 sum과 SIZE를 이용해 평균을 계산하고, average 변수에 저장.

    // 결과 출력
    cout << "합계: " << sum << endl;
    cout << "평균: " << average << endl;

    return 0; // 반환값.
    
    // 궁금한 점 1 - 반환값이란? : main 함수의 반환값은 프로그램이 종료된 후 운영체제나 호출자에게 실행 상태를 전달하는 용도로 사용됨.
    //                             반환값은 정수 데이터(int)로 표현되고 이를 통해 프로그램이 정상적으로 종료되었는지, 오류가 발생했는지 알릴 수 있다.
    // 
    //               return 0; : 프로그램이 정상적으로 실행 및 종료되었음을 알림.
    //               return 1;, return 2; 등 기타 값 : 특정 오류 상태를 나타냄. (파일 열기 실패, 메모리 부족 등)
    //                                                 프로그램이 항상 정상적으로 작동하는 것을 목표로 하더라도, 현실적인 오류 상황을 대비해 반환값을 설정하는 것이 중요함.
    //                                                 
    //                                                 비유 : 반환값은 시험 성적표와 같다.
    //                                                 - 100점(정상 종료): 시험에 통과.
    //                                                 - 50점 이하(오류): 문제를 해결해야 함.
    //                                                 - 성적표를 잘못 작성하면, 성적과 결과를 오해하게 되는 것처럼 반환값도 프로그램 상태를 왜곡할 수 있음.
    // 
    // 궁금한 점 2 - 반환값을 사용해야 하는 이유? : 
    // 
    //   1. 운영체제와의 소통 : 반환값은 프로그램과 운영체제 간의 의사소통 수단. 운영체제는 반환값을 통해 프로그램의 종료 상태를 이해함.
    //   2. 다른 프로그램과의 연동 : 반환값은 다른 프로그램이나 자동화된 스크립트에서 활용됨. 반환값이 성공(0)이면 다음 작업을 진행하고, 오류 값이면 중단하거나 다른 처리를 함.
    //   3. 디버깅 및 문제 해결 : 반환값을 사용하면 프로그램의 종료 상태를 명확히 기록해, 오류 원인을 추적하기 쉬움.
    //
    // 궁금한 점 3 - 정상적으로 작동한 프로그램에서 오류 반환값을 사용하면? :
    //   
    //   1. 운영체제나 호출자가 프로그램을 비정상적으로 종료된 것으로 오해.
    //   2. 다른 프로그램과 연동 시, 의도하지 않은 동작을 유발할 수 있음.
    //   3. 디버깅과 유지보수가 어려워짐.
}

// 합계를 계산하는 함수
int calculateSum(int arr[], int size) 
{
    int sum = 0;
    for (int i = 0; i < size; i++) 
    {
        sum += arr[i];
    }
    return sum; // 여기서 쓰인 반환값은 main 함수에서 쓰인 return 0; 과는 다르다. 두 반환은 동작은 같지만, 의미와 사용 목적이 다르다.

                // return sum;: 배열 합계를 계산한 후 호출한 코드에 전달하는 계산 결과 반환.
                // return 0;: 프로그램이 정상 종료되었음을 운영체제에 알리는 실행 상태 반환.
}

// 평균을 계산하는 함수
double calculateAverage(int sum, int size) 
{
    return static_cast<double>(sum) / size; // sum을 size로 나누고, static_cast<double>로 정수를 실수로 변환하여 소수점 결과를 반환.

    // 여기서의 반환값은 배열의 평균값이다.(실수형)
    // calculateAverage 함수는 합계(sum)를 배열 크기(size)로 나눈 결과를 반환하는 함수로 설계되어 있다.
    // 반환값은 호출한 코드에서 저장하거나 활용할 수 있음.
}

// 코드 실행 과정 요약
// 1.사용자에게 5개의 숫자를 입력받음.
// 2.배열에 입력된 숫자들의 합계를 계산.
// 3.계산된 합계를 이용해 평균을 계산.
// 4.결과(합계와 평균)를 출력.